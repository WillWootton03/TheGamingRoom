# TheGamingRoom
Class CS230 at SNHU 5.25-7.25 Final Project

--Briefly summarize The Gaming Room client and their software requirements. Who was the client? What type of software did they want you to design?

-The Gaming Room was a client that wanted to create a game based application, my job was to work as a consultant and address questions pertaining to the clients needs for which operation platform would best fit their game. This included taking into account things such as implementation for a web based game, storage and memory management, distributed system and networks, and security. All things were taken into account and a final reccomendation was made based on information found in research.

--What did you do particularly well in developing this documentation?

-Research for this project wasn't necessarily too difficult, however making conclusions based on the information found was more challenging. Discovering that Linux was widely used and considered the most popular OS for web-development was all good, though finding out why was more challenging. Once finding out things that make Linux so widely used and viewed as the best putting that into words and explaining accurately what makes Linux the best fit was also a challenge in and of itself.

--What about the process of working through a design document did you find helpful when developing the code?

-The most useful part of the design document I found was the domain model, UML diagrams are quickly becoming very useful in both my school and personal projects as they provide a very clear and concise basis for the code that I was working on. I found myself constantly refering back to the diagram to modify and understand what exactly was in the code and what were the major parts inside each class.

--If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

-I think I could go back and change the reccomendations somewhat, I think as I continue to learn more about OS's and discover new things that I didn't know that my reccommendations might not necessarily change, but the reasoning behind said recommendations might shift slightly as I continue to learn and understand more about operating systems.

--How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

-Users are the single most important part of a software, if a user cannot understand a software then they won't use it, if it doesn't fit their needs they won't use it, and if it plainly stinks to use then again they won't use it. Taking this into account is the single most important reason why user testing, or beta and alpha versions should be released to at least a small group of potential users. We see it all the time in gaming where a game is trashed during the alpha or beta for lacking certain aspects and a team will listen to their consumer and address these issues before release. When a product releases without such public testing you can alienate your community, for example a game like Cyberpunk 2077 released to horrible reviews and ratings, we cannot completely attribute this to not having a beta as it is known that the game more than likely released too early in the development cycle and suffered heavily because of it. This caused the game to be trashed for years until recently after years of bugfixing and changes being made people are revisiting it and giving it high praise. A lack of ability to include your audience and listen to feedback causes not only many games to fail but software as well.

--How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?

-While taking CS230 I was also taking CS250 which introduced me to the Agile-Scrum method of production, when working on a project I believe working not only in sprints, but assigning myself or my team tasks in order from least to most important can greatly help with productivity. For this project I worked on the tasks based on what I felt like in the moment which caused me to bundle up all the tasks that I didn't like at the end which in turn cause me to have a massive headache at the end of it all and might have caused me to take much longer than it should have. Being able to address the most important and sometimes the toughest challenges first can help with making it so in the end you can easily work through the easier less taxing stuff.

